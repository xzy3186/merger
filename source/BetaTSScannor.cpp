/** BetaTSScannor.cpp generated by R. Yokoyama 09/06/2018 **/
#include "BetaTSScannor.hpp"

const std::string BetaTSScannor::kMsgPrefix("[BetaTSScannor]:");

void BetaTSScannor::SetReader()
{
    TSScannorBase<PspmtData>::SetReader();
    std::string br_name = yaml_reader_->GetString("PixieBranchName");
    tree_data_ = new TTreeReaderValue<PspmtData>(*tree_reader_,br_name.c_str());
    std::cout << kMsgPrefix << "TTreeReaderValue: " << br_name << " created." << std::endl;

    high_gain_min_ = yaml_reader_->GetDouble("MinHighGainDynEnergy");
    high_gain_max_ = yaml_reader_->GetDouble("MaxHighGainDynEnergy");
    std::cout << kMsgPrefix << "Beta range on dynode high gain: " << high_gain_min_ << " - " << high_gain_max_ << std::endl;
    low_gain_min_ = yaml_reader_->GetDouble("MinLowGainDynEnergy");
    low_gain_max_ = yaml_reader_->GetDouble("MaxLowGainDynEnergy");
    std::cout << kMsgPrefix << "Beta range on dynode low gain: " << low_gain_min_ << " - " << low_gain_max_ << std::endl;
    return;
}

Bool_t BetaTSScannor::IsInGate()
{
    auto high = tree_data_->Get()->high_gain_;
    Bool_t beam_flag = false;
    {   /* if there is a coinsidence with ion detector, record the timestamp and set the flag on */
        const Double_t energy_g = tree_data_->Get()->ion_green_.energy_;
        const Double_t energy_b = tree_data_->Get()->ion_blue_.energy_;
        const Double_t energy_k = tree_data_->Get()->ion_black_.energy_;
        if(energy_g>10. && energy_b>10. && energy_k>10.){
            prev_implant_ = tree_data_->Get()->external_ts_high_;
            beam_flag = true;
        }
    }

    {   /** checks if this is an implant event **/
        /** if there is a coinsidence with one of the desi detectors, record the timestamp and returns false **/
        {
            const Double_t energy = tree_data_->Get()->desi_top_.energy_;
            //if( energy > 10. && beam_flag ){
            if( energy > 10. ){
                prev_implant_ = tree_data_->Get()->external_ts_high_;
                return false;
            }
        }
        {
            const Double_t energy = tree_data_->Get()->desi_bottom_.energy_;
            //if( energy > 10. && beam_flag ){
            if( energy > 10.  ){
                prev_implant_ = tree_data_->Get()->external_ts_high_;
                return false;
            }
        }
    }

    {   /* checks if there is a coincidence with veto detector */
        const Double_t energy_first = tree_data_->Get()->veto_first_.energy_;
        const Double_t energy_second = tree_data_->Get()->veto_second_.energy_;
        if( energy_first > 10. && energy_second > 10. )
            return false;
    }

    {   /* energy gates on pspmt */
        auto pspmt_high = tree_data_->Get()->high_gain_;
        auto pspmt_low = tree_data_->Get()->low_gain_;
        //if(pspmt_high.energy_<400 || pspmt_high.energy_>4050 )
        //if(pspmt_high.energy_>4050 )
        //    return false;
        //if(pspmt_low.energy_>2000)
        //    return false;
        //if(pspmt_high.valid_ == 0 )
        //    return false;
    }

    //{
    //    auto pspmt_ts_high = tree_data_->Get()->external_ts_high_;
    //    if(pspmt_ts_high-prev_implant_ < 50E+3/40. && pspmt_ts_high-prev_implant_>0)
    //        return false;
    //}

    return true;
}

